package pkg

import (
	"bytes"
	"errors"
	"fmt"
	"regexp"
	"strings"
	"text/template"

	"github.com/jinzhu/inflection"
	"github.com/lapix-com-co/dataloader/pkg/inspection"
)

// Provider refers to the kind of implementation that is choosen.
type Provider string

var (
	ErrNotFound = errors.New("the given item does not exists")
)

// TODO add Postgre, MongoDB, Cache Layer with Redis, etc.

// MySQL is the only provider implementation by now.
const MySQL Provider = "mysql"

// LoaderInput holds the options of the new loader.
type LoaderInput struct {
	Pattern        []string
	Type           string
	TableName      string
	OrderKey       string
	CreatePageType bool
	Expose         bool
	Provider       Provider

	packageName string
}

// BuildLoader returns the content of the new Loader.
func BuildLoader(i LoaderInput) ([]byte, error) {
	methods, err := parsePackage(&i)
	if err != nil {
		return nil, err
	}

	findTableName(&i)
	findOrderKey(&i)

	return buildDataLoaderContent(&i, methods), nil
}

// parsePackage checks if the type exists and validate that there is a valid
// interface which has the form <TypeName>DataLoader. Does not matter if the
// interface is exposed or not.
// Returns the methods to be implemented or error if the type or the interface does
// not exists.
func parsePackage(i *LoaderInput) ([]string, error) {
	if i.Type == "" {
		return nil, errors.New("the type can not be empty")
	}

	result, err := inspection.CheckTypes(i.Pattern, []string{i.Type})
	if err != nil {
		return nil, err
	}

	if !result[0] {
		return nil, fmt.Errorf("could not find the type '%s'", i.Type)
	}

	interfaceName := fmt.Sprintf("%sDataLoader", i.Type)
	result, err = inspection.CheckTypes(i.Pattern, []string{interfaceName})
	if err != nil {
		return nil, err
	}

	if !result[0] {
		interfaceName = fmt.Sprintf("%sDataLoader", strings.ToLower(i.Type))
		result, err = inspection.CheckTypes(i.Pattern, []string{interfaceName})
		if err != nil {
			return nil, err
		}

		if !result[0] {
			return nil, fmt.Errorf("could not found a data loader interface")
		}
	}

	names, err := inspection.Names(i.Pattern)
	if err != nil {
		return nil, err
	}

	i.packageName = names[0]

	methods, err := inspection.Methods(i.Pattern, interfaceName)
	if err != nil {
		return nil, err
	}

	return methods, nil
}

func buildDataLoaderContent(i *LoaderInput, methods []string) []byte {
	var methodsMap = make(map[string]string, 0)

	for _, method := range methods {
		methodsMap[method] = method
	}

	_, hasAllMethod := methodsMap["All"]
	_, hasFindOne := methodsMap["FindOne"]
	contentToParse := baseTemplateHeader

	contentToParse = fmt.Sprintf("%s%s%s", contentToParse, imports(hasAllMethod), pageTypes)

	if _, ok := methodsMap["Create"]; ok {
		contentToParse = fmt.Sprintf("%s%s", contentToParse, createMethod)
	}

	if _, ok := methodsMap["Update"]; ok {
		contentToParse = fmt.Sprintf("%s%s", contentToParse, updateMethod)
	}

	if _, ok := methodsMap["Delete"]; ok {
		contentToParse = fmt.Sprintf("%s%s", contentToParse, deleteMethod)
	}

	if _, ok := methodsMap["Find"]; ok || hasFindOne {
		contentToParse = fmt.Sprintf("%s%s", contentToParse, findMethod)
	}

	if hasFindOne {
		contentToParse = fmt.Sprintf("%s%s", contentToParse, findOneMethod)
	}

	if hasAllMethod {
		contentToParse = fmt.Sprintf("%s%s", contentToParse, allMethod)
	}

	tpl := template.New("file-content")
	tpl, err := tpl.Parse(fmt.Sprintf("%s%s", contentToParse, tableMethod))
	if err != nil {
		panic(err)
	}

	content := bytes.NewBuffer([]byte{})
	if err = tpl.Execute(content, struct {
		Package   string
		Type      string
		LowerType string
		TableName string
		OrderKey  string
	}{
		Package:   i.packageName,
		Type:      i.Type,
		LowerType: strings.ToLower(i.Type[:1]) + i.Type[1:],
		TableName: i.TableName,
		OrderKey:  i.OrderKey,
	}); err != nil {
		panic(err)
	}

	return content.Bytes()
}

// findTableName sets the table name, if the input already has one it won't change.
func findTableName(i *LoaderInput) {
	if i.TableName != "" {
		return
	}

	i.TableName = toSnakeCase(inflection.Plural(i.Type))
}

// findOrderKey sets the key to paginate, if it's empty "id" will be selected.
func findOrderKey(i *LoaderInput) {
	if i.OrderKey == "" {
		i.OrderKey = "id"
	}
}

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func toSnakeCase(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}

var baseTemplateHeader = `// Code generated by github.com/lapix-com-co/dataloader; do not edit!

package {{.Package}}
`

func imports(addStrconv bool) string {
	var result = `
import (
	"context"
	"errors"
	"fmt"
`
	if addStrconv {
		result += `	"strconv"
`
	}

	result += `
	"github.com/jinzhu/gorm"
	"github.com/lapix-com-co/dataloader/pkg"
	"github.com/lapix-com-co/dataloader/pkg/slice"
	"github.com/lapix-com-co/dataloader/pkg/pagination"
	local "github.com/lapix-com-co/dataloader/pkg/gorm"
)
`

	return result
}

var pageTypes = `
type {{.Type}}Page struct {
	Nodes    []*{{.Type}}
	PageInfo pagination.Output
}

type {{.LowerType}}MySQLDataLoader struct {
	db        *gorm.DB
	tableName string
	sortKey   string
}

func New{{.Type}}MySQLDataLoader(db *gorm.DB) *{{.LowerType}}MySQLDataLoader {
	return &{{.LowerType}}MySQLDataLoader{
		db:        db,
		tableName: "{{.TableName}}",
		sortKey:   "{{.OrderKey}}",
	}
}
`

var createMethod = `
func (r *{{.LowerType}}MySQLDataLoader) Create(ctx context.Context, {{.LowerType}} *{{.Type}}) error {
	if err := local.Create(ctx, r.queryTable(), {{.LowerType}}); err != nil {
		return fmt.Errorf("could not create the item: %w", err)
	}

	return nil
}
`

var updateMethod = `
func (r *{{.LowerType}}MySQLDataLoader) Update(ctx context.Context, {{.LowerType}} *{{.Type}}) error {
	if {{.LowerType}}.ID == 0 {
		return errors.New("could not update the item because it does not have a valid ID")
	}

	if err := local.Save(ctx, r.queryTable(), {{.LowerType}}); err != nil {
		return fmt.Errorf("could not update the item: %w", err)
	}

	return nil
}
`

var deleteMethod = `
func (r *{{.LowerType}}MySQLDataLoader) Delete(ctx context.Context, {{.LowerType}} *{{.Type}}) error {
	if err := local.Delete(ctx, r.queryTable(), {{.LowerType}}); err != nil {
		return fmt.Errorf("could not delete the item: %w", err)
	}

	return nil
}
`

var findMethod = `
func (r *{{.LowerType}}MySQLDataLoader) Find(ctx context.Context, i []uint) ([]*{{.Type}}, error) {
	elements := make([]*{{.Type}}, 0)
	if len(i) == 0 {
		return elements, nil
	}

	if err := local.Find(ctx, r.queryTable().Where("id IN (?)", i), &elements); err != nil {
		if errors.Is(err, pkg.ErrRecordNotFound) {
			return nil, err
		}

		return nil, fmt.Errorf("could not find the item: %w", err)
	}

	return elements, nil
}
`

var findOneMethod = `
func (r *{{.LowerType}}MySQLDataLoader) FindOne(ctx context.Context, i uint) (*{{.Type}}, error) {
	elements, err := r.Find(ctx, []uint{i})
	if err != nil {
		return nil, err
	}
	if len(elements) == 0 {
		return nil, fmt.Errorf("%w: '%d'", pkg.ErrNotFound, i)
	}
	return elements[0], nil
}
`

var allMethod = `
func (r *{{.LowerType}}MySQLDataLoader) All(ctx context.Context, i pagination.Input) (*{{.Type}}Page, error) {
	return r.paginateElements(ctx, r.queryTable(), i)
}

func (r *{{.LowerType}}MySQLDataLoader) paginateElements(ctx context.Context, query *gorm.DB, i pagination.Input) (*{{.Type}}Page, error) {
	elements := make([]*{{.Type}}, 0)
	total, err := local.Count(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("could not count the total items: %w", err)
	}

	if total == 0 {
		return create{{.Type}}PageInfo(elements, 0, i), nil
	}

	if err = local.Find(ctx, r.applyPaginationToQuery(query, i), &elements); err != nil {
		return nil, fmt.Errorf("could not query the items: %w", err)
	}

	if i.Last != nil {
		slice.Reverse(elements)
	}

	return create{{.Type}}PageInfo(elements, total, i), nil
}

func (r *{{.LowerType}}MySQLDataLoader) applyPaginationToQuery(query *gorm.DB, input pagination.Input) *gorm.DB {
	if input.After != nil {
		query = query.Where(fmt.Sprintf("%s > ?", r.sortKey), *input.After)
	} else if input.Before != nil {
		query = query.Where(fmt.Sprintf("%s < ?", r.sortKey), *input.Before)
	}

	if input.Last != nil {
		query = query.Order(fmt.Sprintf("%s DESC", r.sortKey)).Limit(*input.Last)
	} else if input.First != nil {
		query = query.Order(fmt.Sprintf("%s ASC", r.sortKey)).Limit(*input.First)
	}

	return query
}

func create{{.Type}}PageInfo(items []*{{.Type}}, totalItems uint32, input pagination.Input) *{{.Type}}Page {
	var page = &{{.Type}}Page{Nodes: items}
	var pageLength = len(items)
	var pageInfo = pagination.Output{
		Total:           totalItems,
		HasNextPage:     true,
		HasPreviousPage: true,
	}

	if pageLength > 0 {
		startCursorID := strconv.Itoa(int(items[0].ID))
		endCursorID := strconv.Itoa(int(items[pageLength-1].ID))

		pageInfo.StartCursor = &startCursorID
		pageInfo.EndCursor = &endCursorID
	}

	if input.Last != nil {
		pageInfo.HasPreviousPage = uint16(pageLength) == *input.Last
		pageInfo.HasNextPage = false
	} else if input.First != nil {
		pageInfo.HasPreviousPage = false
		pageInfo.HasNextPage = uint16(pageLength) == *input.First
	}

	page.PageInfo = pageInfo

	return page
}
`

var tableMethod = `
func (r *{{.LowerType}}MySQLDataLoader) queryTable() *gorm.DB {
	return r.db.New().Table(r.tableName)
}
`
